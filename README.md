# spring-multi-data-source

## EnableMultiDataSourceConfig and MultiDataSourceRepository Annotations

The limitations of using multiple data sources in a single service in Spring are:

1. We need to split the packages of repositories to allow one @EnableJpaRepositories mapped to one
   package for each data source.

2. There is a lot of boilerplate config generation involved to create beans of data sources, entity
   managers, transaction managers etc. for each data source.

3. To get EntityManagerFactoryBuilder injected, we need to declare one of the data sources and all
   its beans as @Primary. Otherwise, service won't even start up.

To mitigate the above limitations, these are two custom annotations in Java that are used for
configuring multi-data source configurations for a service. Let's break down each annotation:

### @EnableMultiDataSourceConfig

- This annotation is used to enable multi-data source configuration for the service.

- It can be applied to a class (target: `ElementType.TYPE`).

- It has the following attributes:
    - `exactEntityPackages`: An array of exact packages to scan for entities. These packages are
      scanned to find the entities related to the data sources.
    - `repositoryPackages`: An array of packages to scan for repositories. These packages are
      scanned to find the repositories related to the data sources.
    - `masterDataSourceName`: The name of the master data source. It is used to generate the
      master beans and name the generated classes, packages, and property paths for the data
      source properties.
    - `dataSourceClassString`: The class name of the master data source. It defines the data
      source bean type.
    - `datasourcePropertiesPrefix`: The prefix of the master data source properties in the
      application properties file.
    - `hikariPropertiesPrefix`: The prefix of the Hikari data source properties in the
      application properties file.
    - `hibernateBeanContainerPropertyPath`: The path of the Hibernate bean container property in
      the application properties.
    - `generatedConfigPackage`: The package where the generated master data source config will
      be placed. The generated config class with relevant beans will follow a specific naming
      format.
    - `generatedRepositoryPackagePrefix`: The prefix of the package where the generated copies
      of the repositories will be placed. The generated repositories will follow a specific
      naming format.

### @MultiDataSourceRepository

- This annotation is used to create copies of repositories in relevant packages and
  autoconfigure them to use the relevant data sources.

- It can be applied to a method (target: `ElementType.METHOD`).

- It has the following attributes:
    - `dataSourceName` (or `value`): The name of the data source to use for the repository.

Both annotations are available at the source level and are not retained at runtime. They are
intended to be used for generating code for configuring data sources during the build process.

### Usage

1. Add `spring-multi-data-source` as a dependency in your service with a scope of `provided`.

   ```xml
   <dependency>
       <groupId>com.dhi13man.spring</groupId>
       <artifactId>spring-multi-data-source</artifactId>
       <version>${desired.version}</version>
       <scope>provided</scope>
   </dependency>
   ```

2. Add the `@EnableMultiDataSourceConfig` annotation to a configuration class in your service, and
   specify the relevant attributes. At bare minimum the `exactEntityPackages`
   and `repositoryPackages` attributes need to be specified.

   ```java
    @Configuration
    @EnableMultiDataSourceConfig(
       repositoryPackages = {
          "com.sample"
       },
       exactEntityPackages = {
          "com.sample.project.payment.payment_service.entities.mysql"
       }
    )
    public class PaymentConfig {
    }
   ```

3. Add the `@MultiDataSourceRepository` annotation to the repository methods that need to be
   configured for a specific data source, and specify the data source name.

      ```java
        @Repository
        public interface PaymentRepository extends JpaRepository<Payment, Long> {
        
           @MultiDataSourceRepository("read-replica")
           Payment findByPaymentId(String paymentId);
        
        }
    ```

4. Build the service and the generated classes will become available in
   the `target/generated-sources/annotations` directory of the service. Add that folder as a
   generated sources root in your IDE.

5. The configuration classes generated by the annotation processor will be named
   `<DataSourceName>DataSourceConfig` and will be placed in the package specified by the
   `generatedConfigPackage` attribute. These classes will provide the beans for the data
   source, transaction manager, entity manager factory, etc. for each data source which can be
   easily autowired with the given name constants.

   For example, if the data source name is `read-replica`, the generated configuration class will be
   named `ReadReplicaDataSourceConfigMysql` and will be placed in the package given by the
   `generatedConfigPackage` attribute.

6. The repositories generated by the annotation processor will be named
   `<DataSourceName><RepositoryName>` and will be placed in the package specified by the
   `generatedRepositoryPackagePrefix` attribute followed by the snake case of the data source name.
   These repositories will be configured to use the relevant data source and can be autowired with
   the given name constants.

   For example, if the data source name is `read-replica` and the repository name
   is `PaymentRepository`, the generated repository will be named `ReadReplicaPaymentRepository` and
   will be placed in the package given by the `generatedRepositoryPackagePrefix` attribute followed
   by `read_replica`.

7. The application data source properties will need to be provided under the key `spring.datasource`
   followed by the kebab case of the data source name.

   ```yaml
   spring:
        datasource:
            master: # This will become the master data source property as opposed to the usual direct spring.datasource property
                driver-class-name: com.mysql.cj.jdbc.Driver
                url: jdbc:mysql://${DB_IP}:${DB_PORT}/${MASTER_DB_NAME}
                username: ${DB_USERNAME}
                password: ${DB_PASSWORD}
                type: com.zaxxer.hikari.HikariDataSource
            read-replica: # This will become the kebab case of the data source name
                driver-class-name: com.mysql.cj.jdbc.Driver
                url: jdbc:mysql://${READ_REPLICA_DB_IP}:${DB_PORT}/${READ_REPLICA_DB_NAME}
                username: ${DB_USERNAME}
                password: ${DB_PASSWORD}
                type: com.zaxxer.hikari.HikariDataSource
   ```

8. Please always go through the generated code to learn more about what configs to give and what
   beans to use for each data source.
